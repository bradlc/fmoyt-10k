{"version":3,"sources":["_inert.js","main.js"],"names":["once","fn","context","result","apply","this","arguments","flip","e","preventDefault","poster","document","querySelector","_focusableElementsString","image","src","currentSrc","style","backgroundImage","classList","add","fromRect","movie","getBoundingClientRect","toRect","scale","width","left","top","transform","modalActive","remove","opacity","addEventListener","setAttribute","_makeSubtreeUnfocusable","inert","focusedItem","focus","borderRadius","_inertManager","requestAnimationFrame","_rootElement","rootElement","setFocusedItem","event","target","closest","getNodeIndex","node","i","startNode","previousElementSibling","composedTreeWalk","callback","shadowRootAncestor","nodeType","Node","ELEMENT_NODE","element","shadowRoot","webkitShadowRoot","localName","content","distributedNodes","getDistributedNodes","length","slot","assignedNodes","flatten","child","firstChild","nextSibling","addInertStyle","createElement","textContent","appendChild","join","InertRoot","inertManager","_managedNodes","Set","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","disconnect","removeAttribute","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","next","done","inertNode","value","_unmanageNode","_visitNode","activeElement","contains","root","undefined","DOCUMENT_FRAGMENT_NODE","parentNode","blur","hasAttribute","_adoptInertRoot","matches","_manageNode","register","deregister","delete","inertSubroot","getInertRoot","setInert","_step2","managedNodes","_iteratorNormalCompletion2","_iterator2","savedInertNode","records","self","_step3","_iteratorNormalCompletion3","_iterator3","record","type","_step4","Array","from","addedNodes","_iteratorNormalCompletion4","_iterator4","_step5","removedNodes","_iteratorNormalCompletion5","_iterator5","_unmanageSubtree","attributeName","_step6","_iteratorNormalCompletion6","_iterator6","managedNode","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_destroyed","ensureUntabbable","_throwIfDestroyed","hasSavedTabIndex","savedTabIndex","destroyed","Error","tabIndex","_savedTabIndex","size","destructor","InertManager","_document","Map","_watchForInert","head","body","documentElement","readyState","_onDocumentLoaded","has","set","parent","get","addInertRoot","removeInertRoot","inertElements","querySelectorAll","_step7","_iteratorNormalCompletion7","_iterator7","inertElement","_step8","_iteratorNormalCompletion8","_iterator8","_step9","_iteratorNormalCompletion9","_iterator9","unshift","_step10","_iteratorNormalCompletion10","_iterator10","defineProperty","Element","prototype","activeItem","main","movieContainer","movieContainerBg","movieInner","movieFront","movieBack","movieBackPoster","items","UP","RIGHT","DOWN","LEFT","ESC","perRow","newTop","which","activeEl","currentIndex","newIndex"],"mappings":"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","file":"main.js","sourcesContent":["/**\n *\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function(document) {\n\n/** @type {string} */\nconst _focusableElementsString = ['a[href]',\n                                  'area[href]',\n                                  'input:not([disabled])',\n                                  'select:not([disabled])',\n                                  'textarea:not([disabled])',\n                                  'button:not([disabled])',\n                                  'iframe',\n                                  'object',\n                                  'embed',\n                                  '[contenteditable]'].join(',');\n\n/**\n * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n * attribute.\n *\n * Its main functions are:\n *\n * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n *   instance exists for each focusable node which has at least one inert root as an ancestor.\n *\n * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n *   attribute is removed from the root node). This is handled in the destructor, which calls the\n *   `deregister` method on `InertManager` for each managed inert node.\n */\nclass InertRoot {\n  /**\n   * @param {Element} rootElement The Element at the root of the inert subtree.\n   * @param {InertManager} inertManager The global singleton InertManager object.\n   */\n  constructor(rootElement, inertManager) {\n    /** @type {InertManager} */\n    this._inertManager = inertManager;\n\n    /** @type {Element} */\n    this._rootElement = rootElement;\n\n    /**\n     * @type {Set<Node>}\n     * All managed focusable nodes in this InertRoot's subtree.\n     */\n    this._managedNodes = new Set([]);\n\n    // Make the subtree hidden from assistive technology\n    this._rootElement.setAttribute('aria-hidden', 'true');\n\n    // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n    this._makeSubtreeUnfocusable(this._rootElement);\n\n    // Watch for:\n    // - any additions in the subtree: make them unfocusable too\n    // - any removals from the subtree: remove them from this inert root's managed nodes\n    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable element,\n    //   make that node a managed node.\n    this._observer = new MutationObserver(this._onMutation.bind(this));\n    this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n   * stored in this object and updates the state of all of the managed nodes.\n   */\n  destructor() {\n    this._observer.disconnect();\n    this._observer = null;\n\n    if (this._rootElement)\n      this._rootElement.removeAttribute('aria-hidden');\n    this._rootElement = null;\n\n    for (let inertNode of this._managedNodes)\n      this._unmanageNode(inertNode.node);\n\n    this._managedNodes = null;\n\n    this._inertManager = null;\n  }\n\n  /**\n   * @return {Set<InertNode>} A copy of this InertRoot's managed nodes set.\n   */\n  get managedNodes() {\n    return new Set(this._managedNodes);\n  }\n\n  /**\n   * @param {Node} startNode\n   */\n  _makeSubtreeUnfocusable(startNode) {\n    composedTreeWalk(startNode, (node) => { this._visitNode(node); });\n\n    let activeElement = document.activeElement;\n    if (!document.contains(startNode)) {\n      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n      let node = startNode;\n      let root = undefined;\n      while (node) {\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          root = node;\n          break;\n        }\n        node = node.parentNode;\n      }\n      if (root)\n        activeElement = root.activeElement\n    }\n    if (startNode.contains(activeElement))\n      activeElement.blur();\n  }\n\n  /**\n   * @param {Node} node\n   */\n  _visitNode(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return;\n\n    // If a descendant inert root becomes un-inert, its descendants will still be inert because of this\n    // inert root, so all of its managed nodes need to be adopted by this InertRoot.\n    if (node !== this._rootElement && node.hasAttribute('inert'))\n      this._adoptInertRoot(node);\n\n    if (node.matches(_focusableElementsString) || node.hasAttribute('tabindex'))\n      this._manageNode(node);\n  }\n\n  /**\n   * Register the given node with this InertRoot and with InertManager.\n   * @param {Node} node\n   */\n  _manageNode(node) {\n    const inertNode = this._inertManager.register(node, this);\n    this._managedNodes.add(inertNode);\n  }\n\n  /**\n   * Unregister the given node with this InertRoot and with InertManager.\n   * @param {Node} node\n   */\n  _unmanageNode(node) {\n    const inertNode = this._inertManager.deregister(node, this);\n    if (inertNode)\n      this._managedNodes.delete(inertNode);\n  }\n\n  /**\n   * Unregister the entire subtree starting at `startNode`.\n   * @param {Node} startNode\n   */\n  _unmanageSubtree(startNode) {\n    composedTreeWalk(startNode, (node) => { this._unmanageNode(node); });\n  }\n\n  /**\n   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n   * @param {Node} node\n   */\n  _adoptInertRoot(node) {\n    let inertSubroot = this._inertManager.getInertRoot(node);\n\n    // During initialisation this inert root may not have been registered yet,\n    // so register it now if need be.\n    if (!inertSubroot) {\n      this._inertManager.setInert(node, true);\n      inertSubroot = this._inertManager.getInertRoot(node);\n    }\n\n    for (let savedInertNode of inertSubroot.managedNodes)\n      this._manageNode(savedInertNode.node);\n  }\n\n  /**\n   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n   * @param {MutationRecord} records\n   * @param {MutationObserver} self\n   */\n  _onMutation(records, self) {\n    for (let record of records) {\n      const target = record.target;\n      if (record.type === 'childList') {\n        // Manage added nodes\n        for (let node of Array.from(record.addedNodes))\n          this._makeSubtreeUnfocusable(node);\n\n        // Un-manage removed nodes\n        for (let node of Array.from(record.removedNodes))\n          this._unmanageSubtree(node);\n      } else if (record.type === 'attributes') {\n        if (record.attributeName === 'tabindex') {\n          // Re-initialise inert node if tabindex changes\n          this._manageNode(target);\n        } else if (target !== this._rootElement &&\n                   record.attributeName === 'inert' &&\n                   target.hasAttribute('inert')) {\n          // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n          // already managed nodes from this inert subroot.\n          this._adoptInertRoot(target);\n          const inertSubroot = this._inertManager.getInertRoot(target);\n          for (let managedNode of this._managedNodes) {\n            if (target.contains(managedNode.node))\n              inertSubroot._manageNode(managedNode.node);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * `InertNode` initialises and manages a single inert node.\n * A node is inert if it is a descendant of one or more inert root elements.\n *\n * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n * is intrinsically focusable or not.\n *\n * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n * or removes the `tabindex` attribute if the element is intrinsically focusable.\n */\nclass InertNode {\n  /**\n   * @param {Node} node A focusable element to be made inert.\n   * @param {InertRoot} inertRoot The inert root element associated with this inert node.\n   */\n  constructor(node, inertRoot) {\n    /** @type {Node} */\n    this._node = node;\n\n    /** @type {boolean} */\n    this._overrodeFocusMethod = false;\n\n    /**\n     * @type {Set<InertRoot>} The set of descendant inert roots.\n     *    If and only if this set becomes empty, this node is no longer inert.\n     */\n    this._inertRoots = new Set([inertRoot]);\n\n    /** @type {boolean} */\n    this._destroyed = false;\n\n    // Save any prior tabindex info and make this node untabbable\n    this.ensureUntabbable();\n  }\n\n  /**\n   * Call this whenever this object is about to become obsolete.\n   * This makes the managed node focusable again and deletes all of the previously stored state.\n   */\n  destructor() {\n    this._throwIfDestroyed();\n\n    if (this._node) {\n      if (this.hasSavedTabIndex)\n        this._node.setAttribute('tabindex', this.savedTabIndex);\n      else\n        this._node.removeAttribute('tabindex');\n\n      // Use `delete` to restore native focus method.\n      if (this._overrodeFocusMethod)\n        delete this._node.focus;\n    }\n    this._node = null;\n    this._inertRoots = null;\n\n    this._destroyed = true;\n  }\n\n  /**\n   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n   * If the object has been destroyed, any attempt to access it will cause an exception.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n\n  _throwIfDestroyed() {\n    if (this.destroyed)\n      throw new Error(\"Trying to access destroyed InertNode\");\n  }\n\n  /** @return {boolean} */\n  get hasSavedTabIndex() {\n    return '_savedTabIndex' in this;\n  }\n\n  /** @return {Node} */\n  get node() {\n    this._throwIfDestroyed();\n    return this._node;\n  }\n\n  /** @param {number} tabIndex */\n  set savedTabIndex(tabIndex) {\n    this._throwIfDestroyed();\n    this._savedTabIndex = tabIndex;\n  }\n\n  /** @return {number} */\n  get savedTabIndex() {\n    this._throwIfDestroyed();\n    return this._savedTabIndex;\n  }\n\n  /** Save the existing tabindex value and make the node untabbable and unfocusable */\n  ensureUntabbable() {\n    const node = this.node;\n    if (node.matches(_focusableElementsString)) {\n      if (node.tabIndex === -1 && this.hasSavedTabIndex)\n        return;\n\n      if (node.hasAttribute('tabindex'))\n        this._savedTabIndex = node.tabIndex;\n      node.setAttribute('tabindex', '-1');\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        node.focus = function() {};\n        this._overrodeFocusMethod = true;\n      }\n    } else if (node.hasAttribute('tabindex')) {\n      this._savedTabIndex = node.tabIndex;\n      node.removeAttribute('tabindex');\n    }\n  }\n\n  /**\n   * Add another inert root to this inert node's set of managing inert roots.\n   * @param {InertRoot} inertRoot\n   */\n  addInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.add(inertRoot);\n  }\n\n  /**\n   * Remove the given inert root from this inert node's set of managing inert roots.\n   * If the set of managing inert roots becomes empty, this node is no longer inert,\n   * so the object should be destroyed.\n   * @param {InertRoot} inertRoot\n   */\n  removeInertRoot(inertRoot) {\n    this._throwIfDestroyed();\n    this._inertRoots.delete(inertRoot);\n    if (this._inertRoots.size === 0)\n      this.destructor();\n  }\n}\n\n/**\n * InertManager is a per-document singleton object which manages all inert roots and nodes.\n *\n * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n * is created for each such node, via the `_managedNodes` map.\n */\nclass InertManager {\n  /**\n   * @param {Document} document\n   */\n  constructor(document) {\n    if (!document)\n      throw new Error('Missing required argument; InertManager needs to wrap a document.');\n\n    /** @type {Document} */\n    this._document = document;\n\n    /**\n     * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n     * @type {Map<Node, InertNode>}\n     */\n    this._managedNodes = new Map();\n\n    /**\n     * All inert roots known to this InertManager. In a map to allow looking up by Node.\n     * @type {Map<Node, InertRoot>}\n     */\n    this._inertRoots = new Map();\n\n    /**\n     * Observer for mutations on `document.body`.\n     * @type {MutationObserver}\n     */\n    this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n\n    // Add inert style.\n    addInertStyle(document.head || document.body || document.documentElement);\n\n    // Wait for document to be loaded.\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n    } else {\n      this._onDocumentLoaded();\n    }\n  }\n\n  /**\n   * Set whether the given element should be an inert root or not.\n   * @param {Element} root\n   * @param {boolean} inert\n   */\n  setInert(root, inert) {\n    if (inert) {\n      if (this._inertRoots.has(root))   // element is already inert\n        return;\n\n      const inertRoot = new InertRoot(root, this);\n      root.setAttribute('inert', '');\n      this._inertRoots.set(root, inertRoot);\n      // If not contained in the document, it must be in a shadowRoot.\n      // Ensure inert styles are added there.\n      if (!this._document.body.contains(root)) {\n        let parent = root.parentNode;\n        while (parent) {\n          if (parent.nodeType === 11) {\n            addInertStyle(parent);\n          }\n          parent = parent.parentNode;\n        }\n      }\n    } else {\n      if (!this._inertRoots.has(root))  // element is already non-inert\n        return;\n\n      const inertRoot = this._inertRoots.get(root);\n      inertRoot.destructor();\n      this._inertRoots.delete(root);\n      root.removeAttribute('inert');\n    }\n  }\n\n  /**\n   * Get the InertRoot object corresponding to the given inert root element, if any.\n   * @param {Element} element\n   * @return {InertRoot?}\n   */\n  getInertRoot(element) {\n    return this._inertRoots.get(element);\n  }\n\n  /**\n   * Register the given InertRoot as managing the given node.\n   * In the case where the node has a previously existing inert root, this inert root will\n   * be added to its set of inert roots.\n   * @param {Node} node\n   * @param {InertRoot} inertRoot\n   * @return {InertNode} inertNode\n   */\n  register(node, inertRoot) {\n    let inertNode = this._managedNodes.get(node);\n    if (inertNode !== undefined) {  // node was already in an inert subtree\n      inertNode.addInertRoot(inertRoot);\n      // Update saved tabindex value if necessary\n      inertNode.ensureUntabbable();\n    } else {\n      inertNode = new InertNode(node, inertRoot);\n    }\n\n    this._managedNodes.set(node, inertNode);\n\n    return inertNode;\n  }\n\n  /**\n   * De-register the given InertRoot as managing the given inert node.\n   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n   * node from the InertManager's set of managed nodes if it is destroyed.\n   * If the node is not currently managed, this is essentially a no-op.\n   * @param {Node} node\n   * @param {InertRoot} inertRoot\n   * @return {InertNode?} The potentially destroyed InertNode associated with this node, if any.\n   */\n  deregister(node, inertRoot) {\n    const inertNode = this._managedNodes.get(node);\n    if (!inertNode)\n      return null;\n\n    inertNode.removeInertRoot(inertRoot);\n    if (inertNode.destroyed)\n      this._managedNodes.delete(node);\n\n    return inertNode;\n  }\n\n  /**\n   * Callback used when document has finished loading.\n   */\n  _onDocumentLoaded() {\n    // Find all inert roots in document and make them actually inert.\n    const inertElements = Array.from(this._document.querySelectorAll('[inert]'));\n    for (let inertElement of inertElements)\n      this.setInert(inertElement, true);\n\n    // Comment this out to use programmatic API only.\n    this._observer.observe(this._document.body, { attributes: true, subtree: true, childList: true });\n  }\n\n  /**\n   * Callback used when mutation observer detects attribute changes.\n   * @param {MutationRecord} records\n   * @param {MutationObserver} self\n   */\n  _watchForInert(records, self) {\n    for (let record of records) {\n      switch (record.type) {\n      case 'childList':\n        for (let node of Array.from(record.addedNodes)) {\n          if (node.nodeType !== Node.ELEMENT_NODE)\n            continue;\n          const inertElements = Array.from(node.querySelectorAll('[inert]'));\n          if (node.matches('[inert]'))\n            inertElements.unshift(node);\n          for (let inertElement of inertElements)\n            this.setInert(inertElement, true);\n        }\n        break;\n      case 'attributes':\n        if (record.attributeName !== 'inert')\n          continue;\n        const target = record.target;\n        const inert = target.hasAttribute('inert');\n        this.setInert(target, inert);\n        break;\n      }\n    }\n  }\n}\n\n /**\n  * Recursively walk the composed tree from |node|.\n  * @param {Node} node\n  * @param {(function (Element))=} callback Callback to be called for each element traversed,\n  *     before descending into child nodes.\n  * @param {ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n  */\nfunction composedTreeWalk(node, callback, shadowRootAncestor) {\n  if (node.nodeType == Node.ELEMENT_NODE) {\n    const element = /** @type {Element} */ (node);\n    if (callback)\n      callback(element)\n\n    // Descend into node:\n    // If it has a ShadowRoot, ignore all child elements - these will be picked\n    // up by the <content> or <shadow> elements. Descend straight into the\n    // ShadowRoot.\n    const shadowRoot = element.shadowRoot || element.webkitShadowRoot;\n    if (shadowRoot) {\n      composedTreeWalk(shadowRoot, callback, shadowRoot);\n      return;\n    }\n\n    // If it is a <content> element, descend into distributed elements - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'content') {\n      const content = /** @type {HTMLContentElement} */ (element);\n      // Verifies if ShadowDom v0 is supported.\n      const distributedNodes = content.getDistributedNodes ?\n        content.getDistributedNodes() : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n\n    // If it is a <slot> element, descend into assigned nodes - these\n    // are elements from outside the shadow root which are rendered inside the\n    // shadow DOM.\n    if (element.localName == 'slot') {\n      const slot = /** @type {HTMLSlotElement} */ (element);\n      // Verify if ShadowDom v1 is supported.\n      const distributedNodes = slot.assignedNodes ?\n        slot.assignedNodes({ flatten: true }) : [];\n      for (let i = 0; i < distributedNodes.length; i++) {\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n      }\n      return;\n    }\n  }\n\n  // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n  // element, nor a <shadow> element recurse normally.\n  let child = node.firstChild;\n  while (child != null) {\n    composedTreeWalk(child, callback, shadowRootAncestor);\n    child = child.nextSibling;\n  }\n}\n\n/**\n * Adds a style element to the node containing the inert specific styles\n * @param {Node} node\n */\nfunction addInertStyle(node) {\n  if (node.querySelector('style#inert-style')) {\n    return;\n  }\n  const style = document.createElement('style');\n  style.setAttribute('id', 'inert-style');\n  style.textContent = \"\\n\"+\n                      \"[inert] {\\n\" +\n                      \"  pointer-events: none;\\n\" +\n                      \"  cursor: default;\\n\" +\n                      \"}\\n\" +\n                      \"\\n\" +\n                      \"[inert], [inert] * {\\n\" +\n                      \"  user-select: none;\\n\" +\n                      \"  -webkit-user-select: none;\\n\" +\n                      \"  -moz-user-select: none;\\n\" +\n                      \"  -ms-user-select: none;\\n\" +\n                      \"}\\n\";\n  node.appendChild(style);\n}\n\nconst inertManager = new InertManager(document);\n\nObject.defineProperty(Element.prototype, 'inert', {\n                        enumerable: true,\n                        get: function() { return this.hasAttribute('inert'); },\n                        set: function(inert) { inertManager.setInert(this, inert) }\n                      });\n\n})(document);\n","import './_inert.js';\n\nlet modalActive = false;\nlet activeItem = null;\n\nconst main = document.querySelector('.js-main');\nconst movieContainer = document.querySelector('.js-movie-container');\nconst movieContainerBg = document.querySelector('.js-movie-container-bg');\nconst movie = document.querySelector('.js-movie');\nconst movieInner = document.querySelector('.js-movie-inner');\nconst movieFront = document.querySelector('.js-movie-front');\nconst movieBack = document.querySelector('.js-movie-back');\nconst movieBackPoster = document.querySelector('.js-movie-back-poster');\n\nconst items = document.querySelectorAll('.js-grid-item');\n\nlet focusedItem = null;\n\nconst UP = 38;\nconst RIGHT = 39;\nconst DOWN = 40;\nconst LEFT = 37;\nconst ESC = 27;\n\nmovieContainer.inert = true;\n\n/* eslint-disable */\nfunction once(fn, context) {\n  let result;\n\n  return function () {\n    if (fn) {\n      result = fn.apply(context || this, arguments);\n      fn = null;\n    }\n\n    return result;\n  };\n}\n/* eslint-enable */\n\nfunction flip(e) {\n  if (typeof e !== 'undefined') e.preventDefault();\n\n  const poster = this.querySelector('.js-grid-poster');\n\n  // update poster\n  if (!modalActive) {\n    const image = poster.querySelector('img');\n    const src = typeof image.currentSrc !== 'undefined' ? image.currentSrc : image.src;\n    movieFront.style.backgroundImage = `url('${src}')`;\n    movieBackPoster.style.backgroundImage = `url('${src}')`;\n\n    movieContainer.classList.add('movie-container--visible');\n  }\n\n  const fromRect = movie.getBoundingClientRect();\n  const toRect = poster.getBoundingClientRect();\n\n  const scale = 1 / (fromRect.width / toRect.width);\n  const left = toRect.left - fromRect.left;\n  const top = toRect.top - fromRect.top;\n\n  movie.style.transform = `translate(${left}px, ${top}px)`;\n  movieInner.style.transform = `scale(${scale})`;\n\n  // border radius\n  if (!modalActive) {\n    const borderRadius = 3 * (1 / scale);\n    movieFront.style.borderRadius = `${borderRadius}px`;\n    movieBack.style.borderRadius = `${borderRadius}px`;\n\n    poster.style.opacity = 0;\n\n    movieContainer.inert = false;\n    main.inert = true;\n\n    window.requestAnimationFrame(() => {\n      movieContainer.classList.add('movie-container--animate');\n      movieInner.style.transform = 'none';\n      movie.style.transform = 'none';\n      movieContainerBg.style.opacity = 1;\n      movie.classList.add('movie--flipped');\n    });\n  } else {\n    movie.classList.remove('movie--flipped');\n    movieContainerBg.style.opacity = 0;\n    movie.addEventListener('transitionend', once(() => {\n      poster.style.opacity = 1;\n      movieContainer.classList.remove('movie-container--animate');\n      movieContainer.classList.remove('movie-container--visible');\n      movie.style.transform = 'none';\n      movieInner.style.transform = 'none';\n\n      movieContainer.inert = true;\n      main.inert = false;\n\n      if (focusedItem) {\n        focusedItem.focus();\n      }\n    }));\n  }\n\n  modalActive = !modalActive;\n  activeItem = this;\n}\n\nfunction setFocusedItem(event) {\n  focusedItem = event.target.closest('.js-grid-item');\n}\n\nfor (let i = 0; i < items.length; i++) {\n  items[i].addEventListener('click', flip);\n\n  items[i].addEventListener('focus', setFocusedItem);\n}\n\nmovieContainer.addEventListener('click', () => {\n  flip.bind(activeItem)();\n});\n\n/**\n * Keyboard nav\n */\nlet top = null;\nlet perRow;\nfor (perRow = 0; perRow < items.length; perRow++) {\n  const newTop = items[perRow].getBoundingClientRect().top;\n  if (top !== null && newTop !== top) {\n    break;\n  }\n  top = newTop;\n}\n\ndocument.addEventListener('keydown', e => {\n  if (e.which !== UP && e.which !== RIGHT && e.which !== DOWN && e.which !== LEFT) return;\n  const activeEl = document.activeElement;\n  if (!activeEl.closest('.grid-item')) {\n    items[0].focus();\n    return;\n  }\n  const currentIndex = getNodeIndex(activeEl.closest('.grid-item'));\n  let newIndex;\n  if (e.which === LEFT) {\n    newIndex = currentIndex - 1;\n  }\n  if (e.which === RIGHT) {\n    newIndex = currentIndex + 1;\n  }\n  if (e.which === DOWN) {\n    newIndex = currentIndex + perRow;\n  }\n  if (e.which === UP) {\n    newIndex = currentIndex - perRow;\n  }\n  if (newIndex >= 0 && newIndex < items.length) {\n    items[newIndex].focus();\n  }\n});\n\ndocument.addEventListener('keydown', e => {\n  if (e.which === ESC && modalActive) {\n    flip.bind(activeItem)();\n  }\n});\n\nfunction getNodeIndex(node) {\n  for (var i = 0; node = node.previousElementSibling; i++);\n  return i;\n}\n"],"sourceRoot":"/source/"}